# Notifications and SQLite

- [notifications](#notifications)
    - [types-of-notifications](#types-of-notifications)
    - [advantages-of-notifications](#advantages-of-notifications)
    - [how-notifications-work](#how-notifications-work)
    - [notification-best-practices](#notification-best-practices)
- [notification-builder](#notification-builder)
- [key-components-of-notificationcompatbuilder](#key-components-of-notificationcompatbuilder)
    - [notification-channel-channelid](#notification-channel-channelid)
    - [creating-a-notification-with-notificationcompatbuilder](#creating-a-notification-with-notificationcompatbuilder)
- [essential-methods-for-configuring-notifications](#essential-methods-for-configuring-notifications)
    - [setsmalliconint-iconresid](#setsmalliconint-iconresid)
    - [setcontenttitlecharsequence-title](#setcontenttitlecharsequence-title)
    - [setcontenttextcharsequence-text](#setcontenttextcharsequence-text)
    - [setautocancelboolean-autocancel](#setautocancelboolean-autocancel)
    - [setpriorityint-priority](#setpriorityint-priority)
    - [building-a-simple-notification-example](#building-a-simple-notification-example)
    - [advanced-configuration](#advanced-configuration)
- [intent-to-open-an-activity-on-notification-tap](#intent-to-open-an-activity-on-notification-tap)
    - [intent](#intent)
    - [pendingintent](#pendingintent)
    - [setcontentintent](#setcontentintent)
    - [opening-an-activity-with-extra-data-example](#opening-an-activity-with-extra-data-example)
    - [retrieving-the-data-from-activitytwo](#retrieving-the-data-from-activitytwo)
- [notification-manager](#notification-manager)
    - [key-features-of-notificationmanager](#key-features-of-notificationmanager)
    - [notification-channels](#notification-channels)
        - [creating-a-notification-channel](#creating-a-notification-channel)
    - [notification-permissions](#notification-permissions)
- [databases-in-android](#databases-in-android)
    - [online-data-storage](#online-data-storage)
    - [local-data-storage](#local-data-storage)
    - [choosing-the-right-database](#choosing-the-right-database)
- [sqlite](#sqlite)
    - [key-features-of-sqlite](#key-features-of-sqlite)
    - [advantages-of-sqlite](#advantages-of-sqlite)
    - [use-cases-of-sqlite](#use-cases-of-sqlite)
    - [acid-compliance](#acid-compliance)
    - [data-types](#data-types)
- [key-classes-in-androiddatabasesqlite](#key-classes-in-androiddatabasesqlite)
    - [sqliteopenhelper](#sqliteopenhelper)
    - [sqlitedatabase](#sqlitedatabase)
    - [cursor](#cursor)
    - [contentvalues](#contentvalues)
    - [database-workflow](#database-workflow)
- [example-code-implementation](#example-code-implementation)
    - [data-model](#data-model)
    - [database-helper](#database-helper)
    - [add-user](#add-user)
    - [store-data-in-database](#store-data-in-database)
    - [fetch-data-from-database](#fetch-data-from-database)
    - [delete-data-from-database](#delete-data-from-database)
- [shared-preferences](#shared-preferences)
    - [shared-preferences-common-use-cases](#shared-preferences-common-use-cases)
    - [modes-in-shared-preferences](#modes-in-shared-preferences)
    - [getting-an-instance-of-shared-preferences](#getting-an-instance-of-shared-preferences)
    - [storing-data-in-shared-preferences](#storing-data-in-shared-preferences)
    - [retrieving-data-from-shared-preferences](#retrieving-data-from-shared-preferences)
    - [example-usage-of-shared-preferences](#example-usage-of-shared-preferences)

---

## Notifications

A notification is a message that Android displays outside of an app's user interface (UI).

It allows apps to communicate important information, reminders, or alerts to users, even when the app is not actively open or running in the foreground.

- Reminders: Calendar events, task deadlines.
- Messages: Chat notifications, missed calls.
- Alerts: Breaking news, security warnings, or app-related updates.

Users can tap on a notification to open the app and view more details. 

Notifications can include actions (e.g., reply to a message, dismiss a task) directly from the notification.

### Types of Notifications

Simple Notifications: Provide basic information (e.g., "New message received").
Expandable Notifications: Offer additional details when expanded, such as a summary or preview of a message.
Actionable Notifications: Allow users to interact with the app (e.g., reply, snooze) directly from the notification.
Persistent Notifications: Remain in the notification shade until dismissed (e.g., active downloads).

### Advantages of Notifications

- User Engagement: Keeps users connected with your app.
- Timeliness: Allows communication of real-time updates or reminders.
- Convenience: Enables quick actions without needing to open the app.

### How Notifications Work

Notifications are generated by the app via the `NotificationManager` service.

Notifications are displayed in the status bar and the notification shade. Users can interact with the notification to perform specific actions or open the app.

### Notification Best Practices

- Relevance: Send notifications that are meaningful and avoid spamming users.
- Clarity: Keep the message concise and easy to understand.
- Action-Oriented: Provide direct actions where appropriate to enhance usability.
- Timing: Avoid sending notifications at inappropriate hours.
- Customisation: Allow users to manage notification preferences

## Notification Builder

In Android, notifications are constructed using the `NotificationCompat.Builder` class, which provides methods to define the content and behaviour of a notification.

## Key Components of `NotificationCompat.Builder`

### Notification Channel (`channelID`)

`channelID`: A unique identifier for a notification channel. Required for Android 8.0 (API level 26) and above, as notifications must be associated with a channel.

Controls how notifications behave (e.g., sound, vibration, visibility). Provides a consistent user experience across notifications from the same app.

```java
String channelID = "my_channel";
```

### Creating a Notification with `NotificationCompat.Builder`

```java
NotificationCompat.Builder builder = new NotificationCompat.Builder(this, channelID);
```

## Essential Methods for Configuring Notifications

### `setSmallIcon(int iconResId)`

 Sets a small icon to represent the notification in the status bar.

```java
builder.setSmallIcon(R.drawable.notification_icon);
```

### `setContentTitle(CharSequence title)`

Sets the title displayed in the notification.

```java
builder.setContentTitle("Reminder");
```

### `setContentText(CharSequence text)`

Sets the main message or body text of the notification.

```java
builder.setContentText("Don't forget your meeting at 3 PM.");
```

### `setAutoCancel(boolean autoCancel)`

Automatically dismisses the notification when the user taps on it.

```java
builder.setAutoCancel(true);
```

### `setPriority(int priority)`

Defines the priority level of the notification for Android 7.1 (API level 25) and below.

- `NotificationCompat.PRIORITY_HIGH: For urgent notifications.`
- `NotificationCompat.PRIORITY_LOW: For less important notifications.`

> For Android 8.0 (API level 26) and above, priority is set using the notification channel importance.

```java
builder.setPriority(NotificationCompat.PRIORITY_HIGH);
```

### Building a Simple Notification Example

```java
String channelID = "my_channel";

// Create a notification builder
NotificationCompat.Builder builder = new NotificationCompat.Builder(this, channelID)
        .setSmallIcon(R.drawable.notification_icon)       // Required small icon
        .setContentTitle("Meeting Reminder")              // Title of the notification
        .setContentText("Your meeting starts in 15 minutes.") // Main text of the notification
        .setPriority(NotificationCompat.PRIORITY_HIGH)    // High priority for visibility
        .setAutoCancel(true);                             // Auto-dismiss on tap
```

### Advanced Configuration

> Notification Channels for Android 8.0 and Above

Before creating notifications, a notification channel must be created.

```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    NotificationChannel channel = new NotificationChannel(
        "my_channel",
        "My Channel Name",
        NotificationManager.IMPORTANCE_HIGH
    );
    NotificationManager notificationManager = getSystemService(NotificationManager.class);
    notificationManager.createNotificationChannel(channel);
}
```

You can add actions to notifications to let users respond or perform tasks directly.

```java
builder.addAction(R.drawable.reply_icon, "Reply", replyPendingIntent);
```

## Intent to Open an Activity on Notification Tap

When a user taps a notification, it often opens a specific activity in the app. This functionality is achieved by combining Intent, PendingIntent, and the `setContentIntent()` method of the `NotificationCompat.Builder`.

### Intent

An Intent is used to specify the action that should occur when the notification is tapped. In this case, it launches `ActivityTwo`.

- Open a specific activity when the notification is clicked.
- Pass extra data to the activity if needed.
- Ensure the activity stack is correctly managed.

```java
Intent intent = new Intent(this, ActivityTwo.class);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  // Clear any existing activities on top of ActivityTwo
intent.putExtra("data", "data from main activity");  // Pass extra data to ActivityTwo
```

### PendingIntent

A PendingIntent acts as a wrapper for the intent. It grants the NotificationManager the ability to execute the intent on behalf of the app when the notification is tapped.

For Android 12 (API level 31) and above, it's recommended to use `FLAG_MUTABLE` if the `PendingIntent` needs to be updated later. Use `FLAG_IMMUTABLE` for security if the `PendingIntent` doesnâ€™t need to be modified.

```java
PendingIntent pendingIntent = PendingIntent.getActivity(
    this, 0, intent, PendingIntent.FLAG_MUTABLE);
```

### `setContentIntent()`

This method associates the `PendingIntent` with the notification. When the notification is tapped, the `PendingIntent` executes, triggering the associated intent.

```java
builder.setContentIntent(pendingIntent);  // Attach the pending intent to the notification
```

### Opening an Activity with Extra Data Example

```java
// Create an intent to open ActivityTwo
Intent intent = new Intent(this, ActivityTwo.class);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);  // Clear task stack above ActivityTwo
intent.putExtra("data", "data from main activity");  // Pass data to ActivityTwo

// Create a mutable pending intent
PendingIntent pendingIntent = PendingIntent.getActivity(
    this, 0, intent, PendingIntent.FLAG_MUTABLE);

// Build the notification
NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "my_channel")
        .setSmallIcon(R.drawable.notification_icon)  // Required small icon
        .setContentTitle("Notification Title")       // Notification title
        .setContentText("Tap to open ActivityTwo")   // Notification message
        .setContentIntent(pendingIntent)            // Attach the pending intent
        .setAutoCancel(true);                       // Dismiss notification on tap

// Issue the notification
NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
notificationManager.notify(1, builder.build());
```

### Retrieving the Data from `ActivityTwo`

In `ActivityTwo`, retrieve the extra data using the intent:

```java

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_two);

    // Retrieve the data passed via intent
    String data = getIntent().getStringExtra("data");
    if (data != null) {
        Log.d("ActivityTwo", "Received data: " + data);
    }
}
```

- Task Management: Ensures ActivityTwo is the sole activity in the stack by clearing others above it.
- Data Passing: Allows passing custom data to the activity upon launch.
- User Interaction: Provides a seamless user experience by linking notifications to app functionality.


## Notification Manager

The `NotificationManager` system service is responsible for handling notifications in Android.

### Key Features of NotificationManager

The `NotificationManager` is retrieved using the `getSystemService()` method:

```java
NotificationManager notificationManager = 
    (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
```

The notify() method displays a notification. The unique ID passed to notify() allows the app to update or cancel the notification later:

```java
notificationManager.notify(0, builder.build());
```

### Notification Channels

Starting with Android 8.0, all notifications must be associated with a Notification Channel. These channels manage notification behaviour, such as sound, vibration, and importance.

Check for Existing Channel: Retrieve the channel using `getNotificationChannel`.

Create a New Channel: If the channel doesn't exist, create it with appropriate properties.
- Importance Levels
- Custom Features

#### Creating a Notification Channel

```java
if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
    NotificationChannel notificationChannel = 
        notificationManager.getNotificationChannel("my_channel");
    
    if (notificationChannel == null) {
        notificationChannel = new NotificationChannel(
            "my_channel",                  // Channel ID
            "My Notifications",            // Channel Name
            NotificationManager.IMPORTANCE_HIGH // Importance Level
        );
        
        // Customise the channel
        notificationChannel.setLightColor(Color.BLUE);   // Set notification light colour
        notificationChannel.enableVibration(true);       // Enable vibration
        
        // Register the channel
        notificationManager.createNotificationChannel(notificationChannel);
    }
}
```

### Notification Permissions

From Android 13 onwards, apps must explicitly request the `POST_NOTIFICATIONS` permission to display notifications.

```xml
<!-- Manifest -->
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

```java
// Request permission at runtime
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
    if (ContextCompat.checkSelfPermission(
            this, android.Manifest.permission.POST_NOTIFICATIONS) 
            != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(
            this,
            new String[]{android.Manifest.permission.POST_NOTIFICATIONS},
            101
        );
    }
}
```

No special notification permissions are required for Android versions below API 33.

## Databases in Android

When building Android applications, data storage is a crucial consideration. Android provides options for local storage and online storage, allowing developers to choose the best solution based on the appâ€™s needs.

### Online Data Storage

Online databases store data on remote servers, making it accessible from anywhere with an internet connection. These are particularly useful for apps requiring real-time syncing or global data sharing.

- SQL Server, APIs
- Google Firebase: Realtime Database, Cloud Firestore

### Local Data Storage

Local databases store data directly on the device, ensuring access without internet connectivity. These are ideal for apps requiring fast access or offline functionality.

- SQLite
- ROOM

### Choosing the Right Database

Use Firebase Realtime Database or Cloud Firestore for:
- Real-time updates across multiple devices.
- Global user data syncing.
- Collaborative features like chat or shared to-do lists.

Use SQLite or ROOM for:
- Offline functionality.
- Apps requiring fast local data access.
- Temporary data caching.

## SQLite

### Key Features of SQLite

Serverless Architecture
- SQLite does not rely on a separate server process to manage the database.
- The database engine is embedded within the application itself.
- Simplifies deployment, as no dedicated database server is required.
- Ideal for mobile and standalone applications where server access may not be feasible.

Zero Configuration
- SQLite requires no complex setup or configuration to start using it.
- No need for database installation, server configuration, or user account setup.
- The database can be used immediately after creating it, streamlining development.

Lightweight Single Database File
- All data is stored in a single file, simplifying management and portability.
- Small memory and storage footprint, making it ideal for devices with limited resources.
- Easily move or copy the database file across different systems without compatibility issues.
- Backup and restore are straightforward since all data resides in a single file.

Robust SQL Support
- SQLite implements a significant subset of SQL92, allowing developers to use familiar SQL syntax.
- Complex Queries: Supports advanced SQL operations like filtering, grouping, and ordering.
- Joins: Enables combining data from multiple tables for powerful data analysis.
- Triggers: Supports triggers for automating actions based on database events.
- Views: Allows the creation of virtual tables for simplified and reusable queries.

### Advantages of SQLite

Portability: The single database file can be used across different devices and operating systems without modification.
Efficiency: Designed to consume minimal system resources, making it ideal for mobile, IoT, and embedded systems.
Stability: Proven track record of reliability in production environments.

### Use Cases of SQLite

Mobile applications that require local storage (e.g., Android and iOS apps).
IoT and embedded systems with limited resources.
Desktop applications needing a lightweight, standalone database.
Applications requiring local caching of remote data for offline access.

### ACID Compliance

SQLite adheres to the principles of ACID (Atomicity, Consistency, Isolation, Durability), ensuring reliable and predictable database transactions. This makes SQLite suitable for applications where data integrity is crucial.

Ensures that all operations within a transaction are completed successfully, or none are applied.

In SQLite, if a transaction is interrupted (e.g., by a crash), SQLite automatically rolls back changes to maintain a consistent state.

Guarantees that a database moves from one valid state to another after a transaction.

Ensures that transactions are processed independently and do not interfere with each other. Uses a lock-based mechanism to isolate transactions and prevent conflicts.

Ensures that once a transaction is committed, its changes are permanent, even in the event of a system failure.

### Data Types

- `NULL`
- `INTEGER`
- `REAL`
- `TEXT`
- `BLOB` Binary Large Object

## Key Classes in `android.database.sqlite`

- `SQLiteOpenHelper`: Manages database lifecycle (creation, updates).
- `SQLiteDatabase`: Executes SQL commands.
- `Cursor`: Navigates query results.
- `ContentValues`: Prepares structured data for insertion or updates.

### `SQLiteOpenHelper`

Constructor
- Initialises the helper instance.
- `Context context`: The application context.
- `String name`: The database name.
- `CursorFactory factory`: Usually null.
- `int version`: The database version.

```java
public MyDatabaseHelper(Context context) {
    super(context, "my_database", null, 1); // Version 1
}
```

`onCreate(SQLiteDatabase db)`
- Called only once when the database is created for the first time.
- Used to define tables and initial data.

```java
@Override
public void onCreate(SQLiteDatabase db) {
    String createTable = "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)";
    db.execSQL(createTable);
}
```

`onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)`
- Invoked when the database version is updated to handle schema changes.
- Drop and recreate tables or migrate data as needed.

```java
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    db.execSQL("DROP TABLE IF EXISTS users"); // Removes old table
    onCreate(db); // Creates a new table
}
```

### `SQLiteDatabase`

`SQLiteDatabase` is the primary interface for database operations, such as queries, inserts, updates, and deletes.

- `execSQL(String sql)`: Executes raw SQL queries.
- `insert(String table, String nullColumnHack, ContentValues values)`: Inserts a row into a table.
- `query(...)`: Fetches data with SQL-like options.
- `rawQuery(String query, String[] selectionArgs)`: Executes a raw `SELECT` query.

```java
SQLiteDatabase db = dbHelper.getWritableDatabase();
ContentValues values = new ContentValues();
values.put("name", "John Doe");
db.insert("users", null, values);
```

### `Cursor`

`Cursor` represents the result set of a query, allowing navigation through rows.

- `moveToFirst()`: Moves to the first row.
- `moveToNext()`: Moves to the next row.
- `isAfterLast()`: Checks if the cursor is past the last row.
- `getInt(int columnIndex)`: Retrieves an integer from the current row.
- `getString(int columnIndex)`: Retrieves a string from the current row.

Always close the cursor after use with `cursor.close()` to free resources.

```java
Cursor cursor = db.rawQuery("SELECT * FROM users", null);
if (cursor.moveToFirst()) {
    do {
        int id = cursor.getInt(0);
        String name = cursor.getString(1);
        // Process data
    } while (cursor.moveToNext());
}
cursor.close();
```

### `ContentValues`

`ContentValues` is a key-value structure used to store data for insert and update operations.

- `put(String key, String value)`: Adds a string value.
- `put(String key, int value)`: Adds an integer value.

```java
ContentValues values = new ContentValues();
values.put("name", "Alice");
values.put("age", 25);
db.insert("users", null, values);
```

### Database Workflow

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "my_database";
    private static final int DATABASE_VERSION = 1;

    public MyDatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        String createTable = "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)";
        db.execSQL(createTable);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS users");
        onCreate(db);
    }
}

// Usage
MyDatabaseHelper dbHelper = new MyDatabaseHelper(context);
SQLiteDatabase db = dbHelper.getWritableDatabase();

// Insert data
ContentValues values = new ContentValues();
values.put("name", "Bob");
db.insert("users", null, values);

// Query data
Cursor cursor = db.rawQuery("SELECT * FROM users", null);
if (cursor.moveToFirst()) {
    do {
        int id = cursor.getInt(0);
        String name = cursor.getString(1);
    } while (cursor.moveToNext());
}
cursor.close();
```

## Example Code Implementation

- Database class: to access and manipulate the database
- Data model: to handle the data between the application and database
- Link activity: the activity which provides access to the base.

### Data Model

```java
public class DataModel {
    private String name;
    private String email;
    private int age;

    // Constructor
    public DataModel(String name, int age, String email) {
        this.name = name;
        this.email = email;
        this.age = age;
    }

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### Database Helper

```java
public class DatabaseHelper extends SQLiteOpenHelper {

    // Constants for table and column names
    public static final String USERS = "users";
    public static final String USERNAME = "username";
    public static final String AGE = "age";
    public static final String EMAIL = "email";
    public static final String ID = "id";

    // Constructor
    public DatabaseHelper(@Nullable Context context) {
        super(context, "testuser.db", null, 1);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        // SQL query to create the table
        String createTable = "CREATE TABLE " + USERS + " (" 
                             + ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " 
                             + USERNAME + " TEXT, " 
                             + AGE + " INTEGER, " 
                             + EMAIL + " TEXT)";
        db.execSQL(createTable);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // SQL query to drop the table if it exists
        String dropTable = "DROP TABLE IF EXISTS " + USERS;
        db.execSQL(dropTable);
        onCreate(db);
    }
}
```

### Add User

```java
public boolean addUser(DataModel dataModel) {
    // Get writable database instance
    SQLiteDatabase db = this.getWritableDatabase();

    // Prepare content values to insert
    ContentValues cv = new ContentValues();
    cv.put(USERNAME, dataModel.getName());
    cv.put(AGE, dataModel.getAge());
    cv.put(EMAIL, dataModel.getEmail());

    // Insert the data into the database
    long result = db.insert(USERS, null, cv);

    // Check if insertion was successful
    return result != -1;
}
```

### Store Data in Database

```java
submit.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // Get data from the user input fields
        DataModel data = new DataModel(
            editTextName.getText().toString(),
            Integer.parseInt(editTextAge.getText().toString()),
            editTextEmail.getText().toString()
        );

        // Initialize the database helper and attempt to add the data
        DatabaseHelper databaseHelper = new DatabaseHelper(MainActivity.this);
        boolean success = databaseHelper.addUser(data);

        // Show appropriate message based on the result of adding data
        if (success) {
            Toast.makeText(MainActivity.this, "Data added", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(MainActivity.this, "Data not added", Toast.LENGTH_SHORT).show();
        }
    }
});
```

```java
public List<DataModel> getAllUsers() {
    // Create a list to hold the user data
    List<DataModel> outputList = new ArrayList<>();

    // Get a readable database instance
    SQLiteDatabase db = this.getReadableDatabase();

    // Define the query to fetch all users
    String query = "SELECT * FROM " + USERS;

    // Execute the query and get the results
    Cursor cursor = db.rawQuery(query, null);

    // Check if the cursor has any data
    if (cursor.moveToFirst()) {
        do {
            // Retrieve data from the cursor
            int id = cursor.getInt(0);
            String name = cursor.getString(1);
            int age = cursor.getInt(2);
            String email = cursor.getString(3);

            // Create a DataModel object and add it to the list
            DataModel dataModel = new DataModel(name, age, email);
            outputList.add(dataModel);

        } while (cursor.moveToNext());
    }

    // Close the cursor and database
    cursor.close();
    db.close();

    // Return the list of users
    return outputList;
}
```

### Fetch Data from Database

```java
viewData.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // Create an instance of the DatabaseHelper to interact with the database
        DatabaseHelper databaseHelper = new DatabaseHelper(MainActivity.this);

        // Retrieve all user data from the database
        List<DataModel> data = databaseHelper.getAllUsers();

        // Log the retrieved data for debugging purposes
        Log.d("SQLdata", data.toString());
    }
});
```

```java
public boolean deleteUser(DataModel dataModel) {
    SQLiteDatabase db = this.getWritableDatabase();
    
    // Define the DELETE query
    String query = "DELETE FROM " + USERS + " WHERE " + EMAIL + " = ?";
    
    // Execute the DELETE query
    SQLiteStatement statement = db.compileStatement(query);
    statement.bindString(1, dataModel.getEmail()); // Bind the email parameter

    // Execute the delete statement
    int rowsAffected = statement.executeUpdateDelete();
    
    // If rowsAffected > 0, deletion was successful
    return rowsAffected > 0;
}
```

### Delete Data from Database

```java
deleteData.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // Get input data from the UI
        String name = editTextName.getText().toString();
        int age = Integer.parseInt(editTextAge.getText().toString());
        String email = editTextEmail.getText().toString();

        // Create a DataModel instance with the entered data
        DataModel data = new DataModel(name, age, email);

        // Initialize the DatabaseHelper
        DatabaseHelper databaseHelper = new DatabaseHelper(MainActivity.this);

        // Call deleteUser method to attempt to delete the user
        boolean success = databaseHelper.deleteUser(data);

        // Show a toast message depending on the success of the deletion
        if (success) {
            Toast.makeText(MainActivity.this, "Successfully deleted", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(MainActivity.this, "Failed to delete", Toast.LENGTH_SHORT).show();
        }
    }
});
```

## Shared Preferences

Shared Preferences provide a simple way to store and retrieve small amounts of data in Android applications. Data is stored in key-value pairs, making it easy to save simple configurations or user settings that can persist across app sessions.

- Key-Value Storage: Data is stored as key-value pairs, where each key must be unique.
- Persistent: Data is retained even after the app is closed or the device is restarted.
- Lightweight: Ideal for small amounts of data such as user preferences, flags, or settings.
- Context-Specific: Each Shared Preferences file is associated with a specific application context.

### Shared Preferences Common Use Cases

- User Preferences: Remembering user settings like theme preferences or language choice.
- App Settings: Storing notifications preferences or other app-specific settings.
- Session Data: Caching small amounts of data such as the user's last login time or app session status.

### Modes in Shared Preferences

Shared Preferences can be accessed in different modes, depending on how you want other apps or the system to interact with the data.

`MODE_PRIVATE`
- The data stored in Shared Preferences is private to the application that created it.
- Default mode if no mode is specified.

`MODE_WORLD_READABLE` (deprecated)
- Allows other applications to read the preferences, but not modify them.

`MODE_WORLD_WRITEABLE` (deprecated)
- Allows other applications to both read and write the preferences. This mode is deprecated due to security concerns.

### Getting an Instance of Shared Preferences

To work with Shared Preferences, you need to retrieve a `SharedPreferences` object, either for reading or writing data.

```java
// To get SharedPreferences in private mode
SharedPreferences sharedPreferences = getSharedPreferences("MyPreferences", Context.MODE_PRIVATE);

// Alternatively, you can use the default SharedPreferences
SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
```

### Storing Data in Shared Preferences

You can store simple data types (like String, int, boolean, etc.) in Shared Preferences using `SharedPreferences.Editor`.

```java
SharedPreferences sharedPreferences = getSharedPreferences("MyPreferences", Context.MODE_PRIVATE);
SharedPreferences.Editor editor = sharedPreferences.edit();

// Storing a string
editor.putString("username", "john_doe");

// Storing an integer
editor.putInt("user_age", 25);

// Storing a boolean
editor.putBoolean("isLoggedIn", true);

// Apply changes
editor.apply();  // apply() saves changes asynchronously, commit() is synchronous
```

### Retrieving Data from Shared Preferences

```java
SharedPreferences sharedPreferences = getSharedPreferences("MyPreferences", Context.MODE_PRIVATE);

// Retrieve the data
String username = sharedPreferences.getString("username", "default_name");
int age = sharedPreferences.getInt("user_age", 0); // default value is 0
boolean isLoggedIn = sharedPreferences.getBoolean("isLoggedIn", false); // default value is false
```

### Example Usage of Shared Preferences

```java
// To save the theme selection
SharedPreferences preferences = getSharedPreferences("UserSettings", Context.MODE_PRIVATE);
SharedPreferences.Editor editor = preferences.edit();
editor.putString("theme", "dark");
editor.apply();

// To retrieve the theme setting later
String theme = preferences.getString("theme", "light"); // default is "light"
```
