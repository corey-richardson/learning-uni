# Design Patterns and SOLID Principles

- [design-patterns-in-java](#design-patterns-in-java)
- [types-of-patterns](#types-of-patterns)
    - [creational-patterns](#creational-patterns)
        - [factory-method](#factory-method)
        - [singleton-pattern](#singleton-pattern)
        - [builder-pattern](#builder-pattern)
    - [structural-patterns](#structural-patterns)
        - [adapter-patterns-wrapper](#adapter-patterns-wrapper)
    - [behavioural-patterns](#behavioural-patterns)
        - [observer-pattern](#observer-pattern)
- [mvc-design-pattern](#mvc-design-pattern)
    - [model](#model)
    - [view](#view)
    - [controller](#controller)
    - [mvc-and-other-design-patterns](#mvc-and-other-design-patterns)
    - [how-mvc-works-together](#how-mvc-works-together)
    - [benefits-of-mvc](#benefits-of-mvc)
    - [mvc-example](#mvc-example)
- [solid-design-principles](#solid-design-principles)
    - [single-responsibility-principle-srp](#single-responsibility-principle-srp)
    - [open-closed-principle-ocp](#open-closed-principle-ocp)
    - [liskov-substitution-principle-lsp](#liskov-substitution-principle-lsp)
    - [interface-segregation-principle-isp](#interface-segregation-principle-isp)
    - [dependency-inversion-principle-dip](#dependency-inversion-principle-dip)
- [solid-implementations](#solid-implementations)
    - [srp](#srp)
    - [ocp](#ocp)
    - [lsp](#lsp)
    - [isp](#isp)
    - [dip](#dip)
- [threads-and-processes](#threads-and-processes)
    - [threads-in-java](#threads-in-java)
    - [benefits-of-using-threads](#benefits-of-using-threads)
    - [thread-safety](#thread-safety)
    - [thread-lifecycle](#thread-lifecycle)
    - [threads-in-ui-applications](#threads-in-ui-applications)
    - [worker-threads](#worker-threads)
- [asynctask](#asynctask)
    - [using-asynctask](#using-asynctask)
    - [steps-to-use-asynctask](#steps-to-use-asynctask)

---

## Design Patterns in Java

- Design patterns offer well-established solutions to specific problems or tasks.
- They are language-agnostic strategies for addressing common challenges in object-oriented design.
- A design pattern represents a concept or a theoretical framework, rather than a concrete code implementation.
- As a developer, incorporating design patterns can make your code more flexible, reusable, and maintainable.
- This is especially significant as Java inherently utilises design patterns.
- Adopting design patterns is considered a best practice for crafting efficient and scalable Java applications.

## Types of Patterns

Design patterns are broadly classified into three categories, each addressing a specific aspect of software design:
- ***Creational Patterns:*** Focus on the methods and mechanisms of object creation, ensuring flexibility and reusability in the instantiation process.
- ***Structural Patterns:*** Concerned with the composition and organisation of objects to form larger structures, promoting efficient use of resources and code readability.
- ***Behavioural Patterns:*** Deal with the interaction and communication between objects, defining clear responsibilities and workflows to enhance collaboration and reduce complexity.

Creational Patterns  | Structural Patterns | Behavioural Patterns
:-:                  | :-:                 | :-:
Builder              | Adapter             | Command
Dependency Injection | Facade              | Observer
Singleton            | Decorator           | Strategy
Factory              | Composite           | State

### Creational Patterns

#### Factory Method

- The Factory Method Pattern defines an interface or abstract class for creating objects, delegating the decision of which class to instantiate to subclasses.
- Subclasses take responsibility for creating instances of the desired class.
- This pattern is often referred to as the *Virtual Constructor* due to its ability to create objects dynamically at runtime without specifying the exact class.

![](https://www.tutorialspoint.com/design_pattern/images/factory_pattern_uml_diagram.jpg)

#### Singleton Pattern

- The Singleton Pattern ensures that a class has only one instance and provides a global point of access to it.
- The pattern guarantees that a single instance of the class is created and shared among all other classes.

Forms of Singleton Pattern:
1. Early Instantiation: The instance is created at the time of class loading.
2. Lazy Instantiation: The instance is created only when it is required, ensuring resource efficiency.

Applications of Singleton Pattern
- Widely used in multi-threaded and database applications to maintain consistency and manage shared resources effectively.
- Common use cases include logging, caching, thread pools, and managing configuration settings.

![](https://media.geeksforgeeks.org/wp-content/uploads/20231207174652/Screenshot-2023-12-07-174635.png)

```java
// Lazy Instantiation of Singleton Pattern

// Client code
public class Main {
    public static void main(String[] args) {
        // Accessing Singleton instance
        Singleton instance = Singleton.getInstance();
        instance.showMessage();
    }
}

// Singleton class
class Singleton {
    // Static variable to hold the single instance
    private static Singleton singleInstance;

    // Private constructor to prevent instantiation
    private Singleton() {
        System.out.println("Singleton Instance Created");
    }

    // Static method to provide access to the single instance
    public static Singleton getInstance() {
        if (singleInstance == null) {
            singleInstance = new Singleton(); // Create instance if it doesn't exist
        }
        return singleInstance;
    }

    // Example method
    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}
```

> `singleInstance` ensures that only one instance of the `Singleton` class is created. <br>
> The private constructor prevents external instantiation of the class. <br>
> The instance is created only when getInstance() is called for the first time. <br>
> `getInstance()` provides a single global point of access to the Singleton instance. <br>
> This implementation ensures thread-safety in a single-threaded environment. For multi-threaded use, synchronisation or other thread-safety mechanisms might be required.

```java
// Early Instantiation of Singleton Pattern

public class Singleton {
    // Early creation of the single instance
    private static final Singleton instance = new Singleton();

    // Private constructor to prevent instantiation
    private Singleton() {}

    // Public method to provide access to the single instance
    public static Singleton getInstance() {
        return instance; // Return the pre-created instance
    }
}
```

> The `instance` is created at the time of class loading, ensuring it's always available when needed. <br>
> Private Constructor ensures no external class can create additional instances of `Singleton`. <br>
> This approach is inherently thread-safe because the instance is created during class loading, which is handled by the JVM in a thread-safe manner. <br>
> This approach is suitable when the Singleton instance is lightweight and guaranteed to be used, avoiding the overhead of lazy instantiation.

Using `synchronized` ensures that only one thread can access the `getInstance` method at a time, preventing multiple instances.

```java
// Thread-Safe Lazy Instantiation

public class Singleton {
    // Static variable to hold the single instance
    private static Singleton instance;

    // Private constructor to prevent instantiation
    private Singleton() {}

    // Synchronized method to provide thread-safe access to the instance
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Create instance if it doesn't exist
        }
        return instance;
    }
}
```

> The `synchronized` keyword ensures that multiple threads cannot create multiple instances simultaneously. This guarantees a single instance even in a multithreaded environment.

Synchronising the entire method can have a performance overhead in scenarios where frequent access to the Singleton is needed. For better performance, a double-checked locking mechanism can be used instead.

```java
// Double-Checked Locking

public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### Builder Pattern

- The Builder Pattern allows for the construction of a complex object from simpler components through a step-by-step process.
- Instead of instantiating the object in a single step, it provides finer control by assembling it piece by piece, accommodating optional and mandatory parts.
- It is particularly useful when the object requires intricate configuration or careful assembly of various components.
- Common scenarios include cases where objects cannot be created in a single step, such as during the deserialization of complex data structures or when building objects with numerous optional parameters.
- Provides flexibility and readability in constructing complex objects.
- Helps maintain code clarity by separating the object creation process from its representation.
- Reduces the risk of errors when handling objects with multiple configurations.
- This pattern is widely used in frameworks and APIs to manage complex object creation efficiently.

![](https://refactoring.guru/images/patterns/diagrams/builder/problem1.png?id=11e715c5c97811f848c48e0f399bb05e)

![](https://startertutorials.com/patterns/wp-content/uploads/2013/11/14-bulider-realworld.png)

This design pattern is used here to construct a collection of CDs step by step.

```java
import java.util.ArrayList;
import java.util.List;

// Interface Packing
public interface Packing {
    String pack();
    int price();
}

// Abstract class CD implementing Packing
public abstract class CD implements Packing {
    public abstract String pack();
}

// Abstract class Company extending CD
public abstract class Company extends CD {
    public abstract int price();
}

// Concrete class Sony
public class Sony extends Company {
    @Override
    public int price() {
        return 20;
    }

    @Override
    public String pack() {
        return "Sony CD";
    }
}

// Concrete class Samsung
public class Samsung extends Company {
    @Override
    public int price() {
        return 15;
    }

    @Override
    public String pack() {
        return "Samsung CD";
    }
}

// Class CDType to hold multiple items
public class CDType {
    private List<Packing> items = new ArrayList<>();

    public void addItem(Packing packs) {
        items.add(packs);
    }

    public void getCost() {
        for (Packing packs : items) {
            System.out.println("Cost: " + packs.price());
        }
    }

    public void showItems() {
        for (Packing packing : items) {
            System.out.print("CD Name: " + packing.pack());
            System.out.println(", Price: " + packing.price());
        }
    }
}

// Class CDBuilder to construct CDType
public class CDBuilder {
    public CDType buildSonyCD() {
        CDType cds = new CDType();
        cds.addItem(new Sony());
        return cds;
    }

    public CDType buildSamsungCD() {
        CDType cds = new CDType();
        cds.addItem(new Samsung());
        return cds;
    }
}

// Main class to demonstrate the Builder Pattern
public class Main {
    public static void main(String[] args) {
        CDBuilder cdBuilder = new CDBuilder();

        CDType sonyCDs = 
```

### Structural Patterns

#### Adapter Patterns (Wrapper)

- The Adapter Pattern is used to convert the interface of a class into another interface that a client expects or requires.
- It allows two incompatible classes to work together by adapting one class's interface to the interface the client is familiar with or expecting.
- This pattern is also known as a Wrapper, as it "wraps" one interface to provide the required functionality.

Adapter
- The class that implements the target interface and delegates requests to the adaptee.

Adaptee
- The class with an incompatible interface that needs to be adapted.

Target
- The interface that the client expects.

The Adapter Pattern is particularly useful when integrating third-party libraries or legacy systems with your application, ensuring compatibility with new code without modifying the existing system. *THINK OF PROJECT NEPTUNE C++/ADA WRAPPER.*

```java
// Create an ArrayAdapter with the specified data and layout
ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, R.layout.list_view, buildingArray);

// Find the ListView by its ID
ListView listView = (ListView) findViewById(R.id.buildings_list);

// Set the adapter to the ListView
listView.setAdapter(adapter);
```

### Behavioural Patterns

#### Observer Pattern

- The Observer Pattern defines a one-to-many relationship between objects, where one object (the subject) maintains a list of dependent objects (the observers).
- When the state of the subject changes, all registered observers are notified and automatically updated to reflect the change in state.
- This pattern is particularly useful for handling events or situations where multiple objects need to react to changes in another object's state.

Subject
- The object whose state changes. It keeps track of the observers and notifies them when the state changes.

Observer
- The objects that need to be notified when the state of the subject changes. They register themselves with the subject to receive updates.

Notification
- When the subject's state changes, it sends a notification to all the observers, prompting them to take action based on the updated state.

API calls: For asynchronous operations like network requests, the Observer Pattern can be used to notify the application when data is received or when an operation completes.

User input: The pattern is useful for responding to user interactions (like clicks, keyboard input, etc.) where different parts of the system need to react to these events.

In a scenario where multiple components need to update when a stock price changes, the stock price could be the subject and the components (like price display, alerts, etc.) would be the observers.

```java
import java.util.ArrayList;
import java.util.List;

// Subject
public class Stock {
    private String symbol;
    private double price;
    private List<Observer> observers = new ArrayList<>();

    public Stock(String symbol, double price) {
        this.symbol = symbol;
        this.price = price;
    }

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void setPrice(double price) {
        this.price = price;
        notifyObservers();
    }

    public double getPrice() {
        return price;
    }

    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

// Observer
public interface Observer {
    void update(Stock stock);
}

// Concrete Observer
public class StockDisplay implements Observer {
    @Override
    public void update(Stock stock) {
        System.out.println("Stock price updated: " + stock.getPrice());
    }
}

// Main class to demonstrate Observer Pattern
public class Main {
    public static void main(String[] args) {
        Stock stock = new Stock("AAPL", 150.0);
        StockDisplay display = new StockDisplay();

        stock.addObserver(display);
        stock.setPrice(155.0); // This will notify the observer
    }
}
```

## MVC Design Pattern

The MVC (Model-View-Controller) design pattern is a widely used architectural pattern that separates an application into three main components to promote modularity, maintainability, and scalability.

![](https://miro.medium.com/v2/resize:fit:1118/0*G5TlBPJZgczgpRo8)

### Model

Represents the data and business logic of the application. It is responsible for retrieving, storing, and processing data. The model is independent of the user interface and doesn't directly interact with the presentation layer.

### View

Represents the user interface (UI) or presentation layer. It displays the data to the user and provides a way to interact with the system. The view observes the model for updates and reflects changes when the model's state changes.

### Controller

Acts as an intermediary between the Model and the View. It handles user inputs (like button clicks, keyboard events, etc.) and updates the model accordingly. The controller also updates the view when the model changes.

### MVC and Other Design Patterns

MVC itself is a combination of several design patterns that work together to handle different concerns in an application.

1. Observer Pattern (Used between Model and View)

    - The Observer pattern is used to notify the View when the Model has changed. When the model's data is updated, all the registered views (observers) are notified and updated accordingly. This allows the UI (View) to stay in sync with the underlying data (Model).

2. Composite Pattern (Used in View)

    - The Composite pattern is useful in situations where the View consists of complex hierarchical components (like panels, containers, etc.). The View can be composed of smaller views (like buttons, text fields), and the Composite pattern allows treating both simple and complex UI components uniformly.
    - A Panel might contain several smaller components like Button and Label, and the Composite pattern allows them to be treated as a single entity in the view hierarchy.

3. Strategy Pattern (Used in Controller)

    - The Strategy pattern is used in the Controller to handle various input processing strategies. The controller can implement different strategies for handling user input or different behaviours, such as how to handle a button click or swipe action, and switch between them dynamically.
    - In a game application, the controller may use different strategies to process inputs for different types of games (action, puzzle, etc.).

4. Behavioural Pattern (Used in Controller)

    - Other behavioural patterns, like Command or State, can be applied within the Controller to handle user interactions. The Command pattern, for example, can encapsulate user input as objects (commands) that can be executed, undone, or logged.
    - The State pattern can be used to manage the state of the controller, such as different modes of interaction (e.g., edit mode, view mode).

5. Structural Pattern (Used in View)

    - The Structural patterns are applied in the View layer to organize and structure the UI components. For example, the Adapter pattern could be used to adapt incompatible interfaces between the model data and how it is presented in the view.

### How MVC Works Together

The user interacts with the View, which is the interface they see (e.g., clicking a button, entering text into a form, etc.).

The Controller receives the input from the user and processes it. Based on the action (e.g., button click, form submission), the controller determines what needs to be done—whether it's updating the Model, refreshing the View, or triggering another operation.

If the user's input requires a change in the application's data or business logic, the Controller updates the Model. For example, if a user adds a new item to a shopping cart, the controller will update the Model with this new item.

Once the Model is updated, it notifies the View of the changes using the Observer Pattern. The View, upon receiving this notification, refreshes or updates the UI to reflect the new state of the data.

### Benefits of MVC

#### Separation of Concerns

- MVC enforces a clear separation between data, UI, and user interaction logic. The Model handles the business logic and data, the View manages the user interface, and the Controller handles input and acts as the mediator.

#### Modularity

- Since each component (Model, View, Controller) is separate, they can be developed and maintained independently. For example, developers can work on the business logic (Model) without affecting the UI (View) and vice versa.

#### Reusability

- The Model and Controller components can be reused across multiple views, allowing different UIs to share the same underlying data and logic. This makes it easier to maintain consistency across the application.

#### Scalability

- The MVC pattern makes it easier to extend and scale the application by modifying or adding components. New views can be added without altering the underlying business logic, and additional controllers can be introduced as the complexity of user interactions grows.

### MVC Example 

```java
// Model: Holds the data and business logic
public class Model {
    private String data;
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void setData(String data) {
        this.data = data;
        notifyObservers();
    }

    public String getData() {
        return data;
    }

    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

// View: Displays the data to the user
public class View implements Observer {
    @Override
    public void update(Model model) {
        System.out.println("View updated with data: " + model.getData());
    }
}

// Controller: Handles user input and updates the model
public class Controller {
    private Model model;

    public Controller(Model model) {
        this.model = model;
    }

    public void setDataInModel(String data) {
        model.setData(data); // Passes data to model
    }
}

// Observer Interface
public interface Observer {
    void update(Model model);
}

// Main: Running the application
public class Main {
    public static void main(String[] args) {
        Model model = new Model();
        View view = new View();
        Controller controller = new Controller(model);

        model.addObserver(view); // View observes the model

        controller.setDataInModel("Hello MVC!"); // Update the model, which notifies the view
    }
}
```

1. Model: Holds the data and implements the Observer pattern to notify registered views when the data changes.
2. View: Implements the Observer interface, so it can update itself when the model changes.
3. Controller: Handles user inputs and updates the model, which in turn updates the view.

## SOLID Design Principles

*SOLID* is a mnemonic acronym representing five key principles of object-oriented design. 

These principles are intended to make software systems more understandable, flexible, maintainable, and extensible, ultimately improving code quality.

### Single Responsibility Principle (SRP)

A class should have one, and only one, reason to change. In other words, a class should have only one responsibility or function.

If a class has more than one responsibility, it will likely be harder to maintain, test, and modify. By following SRP, you ensure that each class has a clear, distinct purpose.

If a class handles both user authentication and database interactions, it should be split into two classes: one for authentication and one for database operations.

### Open-Closed Principle (OCP)

A class should be open for extension, but closed for modification. This means you should be able to add new functionality to a class without altering its existing code.

This principle promotes the use of abstraction (e.g., interfaces or abstract classes) and encourages extending existing classes instead of modifying them directly.

In an Android app, if you want to add a new type of notification, you should be able to extend the existing notification class without modifying the original class.

### Liskov Substitution Principle (LSP)

Objects of a derived class should be able to replace objects of the base class without affecting the correctness of the program.

This principle ensures that subclasses can be used interchangeably with their parent class. It promotes consistent behaviour when extending or substituting classes.

If you have a method that accepts a `Shape` object, it should work with any subclass of `Shape` (`Circle`, `Rectangle`) without causing unexpected behaviour.

### Interface Segregation Principle (ISP)

Clients should not be forced to depend on interfaces they do not use. This means it's better to have several smaller, more specific interfaces than a large, general-purpose one.

By following ISP, you avoid bloated interfaces that require classes to implement methods they don't need. It promotes the creation of lightweight, client-specific interfaces.

In an Android app, you might create separate interfaces for `Clickable` and `Focusable` behaviours rather than forcing a class to implement a large `Interactive` interface that includes unnecessary methods.

### Dependency Inversion Principle (DIP)

Depend on abstractions, not on concretions. High-level modules should not depend on low-level modules; both should depend on abstractions.

This principle encourages decoupling by using interfaces or abstract classes rather than concrete classes, allowing for more flexibility and easier testing.

In Android development, instead of having an `Activity` directly depend on a `DatabaseHelper`, you might have both depend on an abstraction like `DatabaseService`. This allows for easier swapping of database implementations, such as using a mock service in unit tests.

## SOLID Implementations

### SRP

To apply the Single Responsibility Principle (SRP) effectively, consider the following analysis:

1. Check the Statement: Review the class and method names to ensure they reflect a single responsibility. For instance, if a class is called UserManager, it should only handle responsibilities related to user management (e.g., creating, deleting users). If it also handles logging, it violates SRP.

2. Ask the Question: Does it make sense for this class or method to have multiple reasons to change? If the answer is yes, you should separate the method or functionality into a different class.

3. Separate Concerns: If a class or method appears to be handling multiple responsibilities, you can refactor it by separating those responsibilities into different, more manageable classes. This leads to loose coupling (components are independent of each other) and high cohesion (each class has a clear, focused purpose).

```java
// Without SRP
public class UserService {
    public void registerUser(String username, String password) {
        // Register user logic
    }

    public void sendEmailNotification(String email) {
        // Logic to send email notification
    }
}
```

```java
// With SRP
public class UserService {
    private EmailService emailService;

    public UserService(EmailService emailService) {
        this.emailService = emailService;
    }

    public void registerUser(String username, String password) {
        // Register user logic
    }
}

public class EmailService {
    public void sendEmailNotification(String email) {
        // Logic to send email notification
    }
}
```

> In this refactored version, `UserService` is only responsible for managing users, while `EmailService` takes care of sending email notifications. *Each class has a single responsibility, making the code easier to maintain and extend.*

### OCP

Assume we have a class `ShapeDrawer` with a method `drawShape` that draws various shapes (e.g., `Circle`, `Rectangle`). 

```java
public class ShapeDrawer {
    public void drawShape(Shape shape) {
        if (shape instanceof Circle) {
            // Draw Circle
        } else if (shape instanceof Rectangle) {
            // Draw Rectangle
        }
    }
}
```

If we want to add a new shape, such as a `Hexagon`, we would need to modify the `drawShape` method.

```java
public class ShapeDrawer {
    public void drawShape(Shape shape) {
        if (shape instanceof Circle) {
            // Draw Circle
        } else if (shape instanceof Rectangle) {
            // Draw Rectangle
        } else if (shape instanceof Hexagon) {
            // Draw Hexagon
        }
    }
}
```

In this example, modifying the `drawShape` method to add support for the `Hexagon` shape violates the *Open-Closed Principle (OCP)* because we had to change the existing code to accommodate a new requirement.

To adhere to the Open-Closed Principle, we can refactor the design using abstract classes and inheritance. We can make the `Shape` class abstract and have concrete subclasses like `Circle`, `Rectangle`, and `Hexagon` that extend it. 

This way, the `ShapeDrawer` class does not need to be modified when a new shape is introduced.

```java
// Abstract Shape class
public abstract class Shape {
    public abstract void draw();
}

// Concrete Circle class
public class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

// Concrete Rectangle class
public class Rectangle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

// Concrete Hexagon class
public class Hexagon extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Hexagon");
    }
}
```

The `ShapeDrawer` class only needs to know how to handle the `Shape` abstraction. It no longer needs to check for the specific type of shape.

```java
public class ShapeDrawer {
    public void drawShape(Shape shape) {
        shape.draw();  // Each shape will draw itself
    }
}
```


### LSP

The Liskov Substitution Principle (LSP) states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. 

LSP is crucial for well-designed inheritance. Whenever we use a superclass, it should be possible to replace it with a subclass and the system should still function correctly.

Consider an example with a `Rectangle` class and a `Square` class, where a square is a type of rectangle (a square **is-a** rectangle). In this example, we are going to check whether replacing a `Rectangle` object with a `Square` object causes any issues in terms of LSP.

```java
// Rectangle class
public class Rectangle {
    protected int length;
    protected int width;

    public void setLength(int length) {
        this.length = length;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int calculateArea() {
        return length * width;
    }
}

// Square class, extends Rectangle
public class Square extends Rectangle {

    @Override
    public void setLength(int length) {
        this.length = length;
        this.width = length;  // In a square, length and width are always the same
    }

    @Override
    public void setWidth(int width) {
        this.width = width;
        this.length = width;  // In a square, length and width are always the same
    }
}
```

In this example, we can see that `Square` inherits from `Rectangle`, but there is a potential issue with how the two classes behave, particularly when methods are overridden.

Firstly, we create a `Rectangle` and set its length and width:

```java
Rectangle rectangle = new Rectangle();
rectangle.setLength(3);
rectangle.setWidth(4);
System.out.println("Rectangle Area: " + rectangle.calculateArea());  // 12
```

Next, substitute `Rectangle` with `Square`:

```java
Square square = new Square();
square.setLength(3);
square.setWidth(4);  // This also sets length = 4 due to the implementation in Square
System.out.println("Square Area: " + square.calculateArea());  // 16
```

Why is this an LSP Violation?

The `Square` class overrides the `setLength` and `setWidth` methods in such a way that both dimensions are always the same for a square.

When we expect to set two independent dimensions (length and width) for a rectangle, this is no longer the case with a `Square`.

Replacing the `Rectangle` with a `Square` breaks the expected behaviour of the `calculateArea` method, because a square enforces that length and width are always the same, which is not true for a rectangle.

This means that the `Square` class is not a *true* substitute for the `Rectangle` class in this case, as substituting one for the other causes the program to behave incorrectly. 

The expected behaviour of the `calculateArea` method (for rectangles) is violated when used with a square.

While it may be true that a `Square` is a special case of a `Rectangle` mathematically, their behaviours are not interchangeable when it comes to how they handle the `setLength` and `setWidth` methods.

The *Liskov Substitution Principle* requires that subclasses should be able to inherit from a superclass and still function as expected, which is not the case here.

To adhere to LSP, we could refactor the design to prevent the issue of setting length and width independently for squares. One option is to create a new class for `Square` without inheriting from `Rectangle`.

```java
// Separate Square class (not inheriting from Rectangle)
public class Square {
    private int side;

    public void setSide(int side) {
        this.side = side;
    }

    public int calculateArea() {
        return side * side;
    }
}
```

Now, `Rectangle` and `Square` are distinct classes, each with its own logic, and replacing one with the other won't break the expected behaviour.

### ISP

The Interface Segregation Principle (ISP) states that a class should not be forced to implement methods that it does not use, and to encourage the use of smaller, more specific interfaces rather than one large interface containing all possible methods.

Consider the `SmartDevice` interface, which defines methods for three different functionalities; printing, scanning, and faxing.

```java
public interface SmartDevice {
    void print(String document);
    void scan(String document);
    void fax(String document);
}
```

Imagine we have an `EconomicPrinter` class, which only needs the printing functionality. However, because it implements the `SmartDevice` interface, it is forced to provide implementations for all three methods (`print`, `scan`, and `fax`), even though it doesn't need or use the `scan` and `fax` methods.

```java
public class EconomicPrinter implements SmartDevice {

    @Override
    public void print(String document) {
        System.out.println("Printing document: " + document);
    }

    @Override
    public void scan(String document) {
        // This is unnecessary and not implemented in EconomicPrinter
        throw new UnsupportedOperationException("Scanning not supported by EconomicPrinter");
    }

    @Override
    public void fax(String document) {
        // This is unnecessary and not implemented in EconomicPrinter
        throw new UnsupportedOperationException("Faxing not supported by EconomicPrinter");
    }
}
```

By adhering to ISP, we can split the large `SmartDevice` interface into smaller, more specific interfaces.

Each interface will represent one specific functionality (`Printer`, `Scanner`, and `FaxMachine`).

```java
// Printer interface
public interface Printer {
    void print(String document);
}

// Scanner interface
public interface Scanner {
    void scan(String document);
}

// FaxMachine interface
public interface FaxMachine {
    void fax(String document);
}
```

Now, we can create classes that implement only the interfaces that are relevant to them.

```java
// EconomicPrinter only implements Printer interface
public class EconomicPrinter implements Printer {
    @Override
    public void print(String document) {
        System.out.println("Printing document: " + document);
    }
}

// AllInOnePrinter implements all relevant interfaces
public class AllInOnePrinter implements Printer, Scanner, FaxMachine {

    @Override
    public void print(String document) {
        System.out.println("Printing document: " + document);
    }

    @Override
    public void scan(String document) {
        System.out.println("Scanning document: " + document);
    }

    @Override
    public void fax(String document) {
        System.out.println("Faxing document: " + document);
    }
}
```

`EconomicPrinter` only implements the Printer interface, which is all it needs. It does not have to implement unnecessary methods like `scan` and `fax`.

`AllInOnePrinter` implements all three interfaces (`Printer`, `Scanner`, and `FaxMachine`), as it supports all the required functionalities.

### DIP

The *Dependency Inversion Principle (DIP)* aims to reduce dependencies between high-level modules and low-level modules by introducing abstractions.

Imagine a simple application that copies data from a source to a destination. 

If we directly depend on concrete implementations for both the source and destination (copying from a file to a database), the system becomes tightly coupled and difficult to modify or extend.

```java
// Design violating DIP
public class DataCopier {
    private FileSource fileSource;   // Low-level module
    private DatabaseDestination databaseDestination;  // Low-level module

    public DataCopier() {
        fileSource = new FileSource();
        databaseDestination = new DatabaseDestination();
    }

    public void copy() {
        String data = fileSource.readData();  // High-level module depending on low-level module
        databaseDestination.saveData(data);  // High-level module depending on low-level module
    }
}
```

Here, the `DataCopier` class depends on specific implementations (`FileSource` and `DatabaseDestination`), making it difficult to change the source or destination types without modifying the `DataCopier` class.

To follow DIP, we introduce an abstraction for the source and destination, allowing high-level modules to depend on the abstractions rather than specific implementations.

```java
// Abstract class for Source
public interface DataSource {
    String readData();
}

// Abstract class for Destination
public interface DataDestination {
    void saveData(String data);
}

// Concrete FileSource class
public class FileSource implements DataSource {
    public String readData() {
        return "Data from file";
    }
}

// Concrete DatabaseDestination class
public class DatabaseDestination implements DataDestination {
    public void saveData(String data) {
        System.out.println("Saving data to database: " + data);
    }
}

// DataCopier class now depends on abstractions, not concrete classes
public class DataCopier {
    private DataSource source;   // High-level module depends on abstraction
    private DataDestination destination;  // High-level module depends on abstraction

    public DataCopier(DataSource source, DataDestination destination) {
        this.source = source;
        this.destination = destination;
    }

    public void copy() {
        String data = source.readData();
        destination.saveData(data);
    }
}
```

Now, the `DataCopier` depends on abstractions (`DataSource` and `DataDestination`) instead of concrete classes.

## Threads and Processes

A process is a program in execution.

It is an independent unit of execution that is allocated resources by the operating system, such as memory and CPU time. Each process runs in its own isolated memory space, meaning that one process cannot directly access the memory of another process. Sub-processes are often spawned by a parent process to perform specific tasks. Each sub-process is a separate entity that has its own resources.

A thread is a smaller unit of execution within a process.

Threads within the same process share the same memory and resources (such as variables, file handles), making communication between them faster and more efficient compared to processes. Threads are lighter weight than processes and incur lower overhead because they do not require their own memory space.

Feature	| Process |Thread
--- | --- | ---
**Definition** | A program in execution. | A smaller unit of execution within a process.
**Memory Space** | Each process has its own memory space. | Threads share memory within the same process.
**Communication** | Processes use IPC (Inter-Process Communication). | Threads communicate directly since they share memory.
**Overhead** | High overhead due to process isolation. | Low overhead due to shared resources within the process.
**Examples** | Web browsers, text editors. | Multiple tabs in a browser, or concurrent functions.

### Threads in Java

In Java, threads are often seen as "mini-processes" because they:
- Execute within the context of a parent process (the Java Virtual Machine or JVM).
- Share the same memory and resources (variables, open files), allowing for easier communication.

The main thread is typically the first thread created when a Java program starts, and it is responsible for running the main method. The main thread often handles the user interface (UI) in applications (e.g., in desktop or mobile apps).

Java applications can create additional threads to perform background tasks, improving responsiveness and enabling multitasking.

The JVM itself is a process that runs the Java application.

When you run a Java program, the main method is executed by the main thread. In IntelliJ IDEA or Android Studio, multiple threads are used for tasks such as handling the editor interface, running code in the background, etc.

Threads make concurrent programming possible, and they are a critical part of creating responsive and efficient applications.

### Benefits of Using Threads

Improved CPU Utilisation
- Threads allow a program to make better use of CPU resources by dividing tasks and executing them concurrently, helping to utilise idle CPU time more efficiently.

Concurrent Execution
- Threads enable multiple tasks to be performed simultaneously, even when handling heavy operations, by alternating execution.

Parallel Task Handling
- Large computational tasks can be split into smaller tasks, with each thread managing a part of the workload, leading to improved efficiency.

Multi-Core Processor Utilisation
- Modern processors have multiple cores. Threads can leverage these cores for parallel execution, enhancing performance by spreading tasks across multiple processors.

### Thread Safety

When multiple threads interact with shared resources, race conditions and collisions can occur, leading to unpredictable behaviour.

Code executed on threads must be thread-safe to ensure consistency and prevent conflicts.

Exception Handling: The `Thread.sleep()` method, for example, requires proper exception handling, specifically dealing with the `InterruptedException` class.

```java
try {
    Thread.sleep(1000);  // Example of thread sleeping
} catch (InterruptedException e) {
    // Handle exception
}
```

### Thread Lifecycle

1. Created: The thread is instantiated but not yet started.
2. Ready: The thread is ready to run, waiting for CPU time.
3. Running: The thread is executing.
4. Sleeping: The thread is in a paused state, typically due to a `sleep()` method call.
5. Blocked: The thread is blocked, usually waiting for a resource.
6. Waiting: The thread is waiting for a condition to be met before proceeding.
7. Dead: The thread has finished its execution.

### Threads in UI Applications

Blocking the Main Thread
- Any long-running task on the main thread (e.g., network operations, heavy computations) will cause the entire application to freeze, resulting in an "Application Not Responding" (ANR) error after a few seconds.

UI Thread (Main Thread)
- The UI thread handles all user interactions and updates to the user interface. If this thread is blocked for too long, the user will perceive the application as frozen.

*Do not block the UI thread:* Long-running operations should not be executed on the main thread. Operations like network access or database queries should be done on separate threads (i.e., worker threads).

*Do not access the UI toolkit outside the UI thread:* Any updates to the user interface should be done only from the UI thread.

Blocking the UI thread for more than a few seconds results in the infamous "ANR" (Application Not Responding) dialog. For Android apps, blocking the UI thread for over 5 seconds causes this issue.

### Worker Threads

Any processing or long-running tasks should be performed in background or worker threads to prevent blocking the UI thread.

You cannot directly update the UI from a background thread. However, Android provides mechanisms to post updates to the UI thread:
- `Activity.runOnUiThread(Runnable)`: Executes code on the UI thread.
- `View.post(Runnable)`: Executes a Runnable on the UI thread.
- `View.postDelayed(Runnable, long)`: Executes a Runnable on the UI thread after a delay.

```java
public void onClick(View v) {
    // Start a new background thread
    new Thread(new Runnable() {
        public void run() {
            // Perform the time-consuming task (image processing)
            final Bitmap bitmap = processBitMap("image.png");

            // Post the UI update to the main thread
            imageView.post(new Runnable() {
                public void run() {
                    // Update the ImageView on the main UI thread
                    imageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();  // Start the background thread
}
```

## `AsyncTask`

### Using `AsyncTask`

`AsyncTask` is a class in Android that allows you to perform background operations while keeping the user interface (UI) responsive. It simplifies handling background tasks without the need to manually manage threads and handlers.

- `doInBackground()`: This method is executed on a worker thread, where you can perform time-consuming tasks like downloading files, processing data, or querying a database. The operations in this method do not block the UI thread.

- `onPostExecute()`: After the background task is completed, the `onPostExecute()` method is called on the UI thread. This method receives the result from `doInBackground()` and is used to update the UI, such as changing a `TextView` or an `ImageView`.

- `execute()`: This method starts the asynchronous task from the UI thread. Once called, it triggers the background work and allows the UI to stay responsive.

### Steps to Use AsyncTask:

1. Subclass `AsyncTask`: You create a custom subclass of `AsyncTask` and override the `doInBackground()` and `onPostExecute()` methods.

2. Implement `doInBackground()`: This method runs the background task. It can return a result which will be passed to `onPostExecute()`.

3. Implement `onPostExecute()`: This method is called after `doInBackground()` completes. It updates the UI with the result from the background operation.

4. Execute the Task: Call the `execute()` method from the UI thread to start the task.

```java
// Define the AsyncTask subclass
private class MyAsyncTask extends AsyncTask<String, Void, Bitmap> {

    // Perform the background operation (do not update UI here)
    @Override
    protected Bitmap doInBackground(String... params) {
        String imagePath = params[0];
        return processBitMap(imagePath); // Time-consuming task
    }

    // Update UI after the background task is finished
    @Override
    protected void onPostExecute(Bitmap result) {
        super.onPostExecute(result);
        imageView.setImageBitmap(result);  // Update the ImageView on the UI thread
    }
}

// Execute the AsyncTask in the UI thread
public void onClick(View v) {
    new MyAsyncTask().execute("image.png"); // Start AsyncTask with the image path
}
```
