# Formal Langauge and Automata

- Regular Expressions
- Chomsky Hierarchy of Formal Languages
    - Regular and Context Free Languages
- Formal Automata or Machines (Models of Computation)
    - Finite State and Pushdown Automata

---

Sequetial Circuits
- Theory of finite state automata

Compilers
- Theory of context free grammars

Cryptography
- Theory of computational complexity

---

## Regular Expressions

Pattern Matching

Notation to specifiy a set of strings; usually an infinite set.

[![](https://images.datacamp.com/image/upload/v1665049689/Regular_Expressions_Cheat_Sheet_b95aae6488.png)](https://images.datacamp.com/image/upload/v1665049689/Regular_Expressions_Cheat_Sheet_b95aae6488.png)

> $\epsilon$ represents empty word

## Finite State Automata

![](https://miro.medium.com/v2/resize:fit:627/1*izz__-XaTNUckGb9BrhPGQ.png)

> `^0(0|1)*` <br>
> 01010101 :heavy_check_mark: <br>
> 00110011 :heavy_check_mark: <br>
> 10101010 :x:

A deterministic finite state automation `M` is a 5-tuple:

$$M=(Q, \Sigma, q_0, F, \delta)$$
- $Q$ is a finite set of states
- $\Sigma$ is a finite set of input symbols ("alphabet")
- $q_0$ is a start state from $Q$
- $F$ is a set of accepting (final) states from $Q$
- $\delta$ is a transition function; i.e a total mapping from $Q * \Sigma$ to $Q$

The transition function $\delta$ takes a state $q$ and an input symbol $a$ and maps them to $a \text{ state } q'$

- store input as an array of symbols 'a' of size n
- store the transition table as a 2D-array T
- start with state q in q0
- iterate through the input and update the state
    - in step i:     q := T [ q, a[i] ]
- if after the loop, q is in the array F of final states the input is accepted, else rejected

```
T = [1, 0; 1, 1]
q = q_0
a = [a_0, a_1, ..., a_{n-1}]
i = 0, ..., n-1
    q = T[q, a[i]]

if q is in F
    return True
else
    return False
```

### Non-Determinism

In a DFA, each pair of state and input symbol uniquely defines a next state.

Non-determinism allows for missing and non-unique transitions (and possibly for more than 1 start state).

If multiple targets exist (non-determinism) the machine is "cloned" and all alternatives run further.

There may be "epsilon-transitions" (without an input).

If a target state cannot be determined the machine dies.

A word is accepted if at least one derivation exists, *i.e. if at least one machine survives in an accepting state*.

## Formal Languages

The set of all words an FSA accepts is called the *language* it accepts.

$$L(A) = \{u \in \Sigma \text{*} \,|\, A \text{ has an accepting run on } u\}$$

For each DFA there exists at least one regular expression that represents the same Language as the DFA (and vice-versa).

For each NFA (non-deterministic) there exists a DFA that accepts the same language.

DFAs NFAs and Regular Expressions all compute the same class of languages.

These are *regular languages*.

## Grammars and Languages

The languages generated by Regular Grammars are exactly the same as those defined by regular expressions.

```
Consider  L = { an bn | n > 0 }
            = { n a's followed by n b's }
            = { ab, aabb, aaabbb, ... }
```

This can not be recognised by a DFA; for any finite n one could have a chain of 2n states, first for n a's and then n b's. However, there is always a larger n.    

This can also not be expressed by a RegExp

## Context Free Grammars

For "Context-Free Grammars" productions can have an arbitrary but finite sequence of variables on the right hand side of any rule.

`A   ::=   B "c" D "e" ;`

However, the left hand side must always be a single variable (without *context* nearby)

`G = ( {S}, {a, b},  {S-->ab, S-->aSb},  S )`

This Grammar generates  `{ a^n b^n | N>0 }`

`S --> aSb --> aaSbb --> aaaSbbb --> aaaabbbb`

> CFLs are more powerful than Regular Languages

## Pushdown Automata

A pushdown automata is a finite state automaton with an additional stack to store some information about the ongoing computation.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Pushdown-overview.svg/340px-Pushdown-overview.svg.png)
